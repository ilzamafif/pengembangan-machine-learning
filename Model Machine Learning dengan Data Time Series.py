# -*- coding: utf-8 -*-
"""submission-revisi-2-time-series

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1CKgIKzqrX0zr2otWo12F1WZRatAvo9s_
"""

import numpy as np
import pandas as pd
from keras.layers import Dense, LSTM
import matplotlib.pyplot as plt
import tensorflow as tf

df = pd.read_csv('https://raw.githubusercontent.com/jbrownlee/Datasets/master/daily-min-temperatures.csv')
df

df.isnull().sum()

df.sort_values(by='Temp', ascending=True)

df.sort_values(by='Temp', ascending=False)

mae_terkecil = 26.3 * 10/100
mae_terkecil

date = df['Date'].values
temp = df['Temp'].values
 
plt.figure(figsize=(20,5))
plt.plot(date, temp)
plt.title('Temperature average', fontsize = 20);

time = np.array(date)
series = np.array(temp)
 
time_split = 2000
X_train = time[:time_split]
X_test = time[time_split:]
y_train = series[:time_split]
y_test = series[time_split:]
 
window_size = 30
batch_size = 32
shuffle_buffer_size = 1000

def windowed_dataset(series, window_size, batch_size, shuffle_buffer):
    series = tf.expand_dims(series, axis = -1)
    ds = tf.data.Dataset.from_tensor_slices(series)
    ds = ds.window(window_size + 1, shift = 1, drop_remainder = True)
    ds = ds.flat_map(lambda w: w.batch(window_size + 1))
    ds = ds.shuffle(shuffle_buffer)
    ds = ds.map(lambda w: (w[:-1], w[1:]))
    return ds.batch(batch_size).prefetch(1)

def model_forecast(model, series, window_size):
    ds = tf.data.Dataset.from_tensor_slices(series)
    ds = ds.window(window_size, shift = 1, drop_remainder = True)
    ds = ds.flat_map(lambda w: w.batch(window_size))
    ds = ds.batch(32).prefetch(1)
    forecast = model.predict(ds)
    return forecast

class myCallback(tf.keras.callbacks.Callback):
  def on_epoch_end(self, epoch, logs={}):
    if(logs.get('mae')is not None and logs.get('mae') <= mae_terkecil):
      print("\nMAE dibawah ", mae_terkecil , ", train data diberhentikan !")
      self.model.stop_training = True
 
callbacks = myCallback()

train_set = windowed_dataset(series = y_train, window_size = 60, batch_size = 100, shuffle_buffer =  shuffle_buffer_size)
model = tf.keras.models.Sequential([
    # tf.keras.layers.Bidirectional(LSTM(60, activation='relu')),
    tf.keras.layers.LSTM(64, return_sequences=True),
    tf.keras.layers.Dense(10, activation = 'relu'),
    tf.keras.layers.Dense(1),
])

optimizer = tf.keras.optimizers.SGD(lr = 1.0000e-04, momentum = 0.9)
model.compile(loss = tf.keras.losses.Huber(),
              optimizer = optimizer,
              metrics = ["mae"])
history = model.fit(train_set, epochs = 100, callbacks=[callbacks]),

rnn_forecast = model_forecast(model, series[..., np.newaxis], window_size)
rnn_forecast = rnn_forecast[time_split - window_size: -1, 0]

def plot_series(time, series, format="-", start=0, end=None):
    plt.plot(time[start:end], series[start:end], format)
    plt.xlabel("Time")
    plt.ylabel("Value")
    plt.grid(True)
 
plt.figure(figsize=(10, 6))
plot_series(X_test, y_test)
plot_series(X_test, rnn_forecast)

tf.keras.metrics.mean_absolute_error(y_test, rnn_forecast).numpy()